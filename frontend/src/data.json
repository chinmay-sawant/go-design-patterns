[
  {
    "name": "behavioral",
    "type": "directory",
    "path": "design_patterns/behavioral",
    "children": [
      {
        "name": "chain_of_responsibility",
        "type": "directory",
        "path": "design_patterns/behavioral/chain_of_responsibility",
        "children": [
          {
            "name": "main.go",
            "type": "file",
            "path": "design_patterns/behavioral/chain_of_responsibility/main.go",
            "content": "package main\n\nimport \"fmt\"\n\n// Chain of Responsibility Pattern\n//\n// 5-Year-Old Explanation:\n// Imagine you want to buy a toy that costs $100.\n// 1. You ask your Big Brother. He has $10. He says \"I can't afford it, ask Dad.\"\n// 2. You ask Dad. He has $50. He says \"I can't afford it, ask Mom.\"\n// 3. You ask Mom. She has $200! She says \"Ok, I'll buy it.\"\n// The request gets passed up the chain until someone can handle it!\n//\n// Real World Scenario:\n// IT Support Desk. You call Level 1 support. If they can't fix it, they escalate to Level 2.\n// If Level 2 can't fix it, they escalate to Level 3 (The Engineers).\n// The request moves up the chain until it finds someone who knows the answer.\n\ntype Handler interface {\n\tSetNext(handler Handler) Handler\n\tHandle(cost int)\n}\n\n// BaseHandler helps us link the chain\ntype BaseHandler struct {\n\tnext Handler\n}\n\nfunc (b *BaseHandler) SetNext(next Handler) Handler {\n\tb.next = next\n\treturn next\n}\n\nfunc (b *BaseHandler) HandleNext(cost int) {\n\tif b.next != nil {\n\t\tb.next.Handle(cost)\n\t} else {\n\t\tfmt.Println(\"End of chain: No one can afford this!\")\n\t}\n}\n\n// -- Concrete Handlers --\n\n// Brother\ntype Brother struct {\n\tBaseHandler\n}\n\nfunc (b *Brother) Handle(cost int) {\n\tif cost <= 10 {\n\t\tfmt.Printf(\"Brother: I have $10. I can buy this toy for $%d!\\n\", cost)\n\t} else {\n\t\tfmt.Printf(\"Brother: I only have $10. Too expensive ($%d). Asking Dad...\\n\", cost)\n\t\tb.HandleNext(cost)\n\t}\n}\n\n// Dad\ntype Dad struct {\n\tBaseHandler\n}\n\nfunc (d *Dad) Handle(cost int) {\n\tif cost <= 50 {\n\t\tfmt.Printf(\"Dad: I have $50. I can buy this toy for $%d!\\n\", cost)\n\t} else {\n\t\tfmt.Printf(\"Dad: I only have $50. Too expensive ($%d). Asking Mom...\\n\", cost)\n\t\td.HandleNext(cost)\n\t}\n}\n\n// Mom\ntype Mom struct {\n\tBaseHandler\n}\n\nfunc (m *Mom) Handle(cost int) {\n\tif cost <= 200 {\n\t\tfmt.Printf(\"Mom: I have $200. I can buy this toy for $%d!\\n\", cost)\n\t} else {\n\t\tfmt.Printf(\"Mom: I only have $200. Too expensive ($%d). We can't buy it.\\n\", cost)\n\t\tm.HandleNext(cost)\n\t}\n}\n\nfunc main() {\n\tfmt.Println(\"--- Chain of Responsibility: Buying a Toy ---\")\n\n\t// Create the chain components\n\tbrother := &Brother{}\n\tdad := &Dad{}\n\tmom := &Mom{}\n\n\t// Link them: Brother -> Dad -> Mom\n\tbrother.SetNext(dad).SetNext(mom)\n\n\t// Test 1: Cheap toy\n\tfmt.Println(\"\\nRequest: Toy costs $5\")\n\tbrother.Handle(5)\n\n\t// Test 2: Medium toy\n\tfmt.Println(\"\\nRequest: Toy costs $40\")\n\tbrother.Handle(40)\n\n\t// Test 3: Expensive toy\n\tfmt.Println(\"\\nRequest: Toy costs $150\")\n\tbrother.Handle(150)\n\n\t// Test 4: Super expensive toy\n\tfmt.Println(\"\\nRequest: Toy costs $500\")\n\tbrother.Handle(500)\n}\n"
          }
        ]
      },
      {
        "name": "command",
        "type": "directory",
        "path": "design_patterns/behavioral/command",
        "children": [
          {
            "name": "main.go",
            "type": "file",
            "path": "design_patterns/behavioral/command/main.go",
            "content": "package main\n\nimport \"fmt\"\n\n// Command Pattern\n//\n// 5-Year-Old Explanation:\n// Imagine a TV Remote Control.\n// Each button is a \"Command\".\n// One button knows how to \"Turn On TV\".\n// Another button knows how to \"Mute Volume\".\n// You (the Invoker) just press the button. You don't need to know how the TV works inside.\n// You can also \"Undo\" if you pressed the wrong button!\n//\n// Real World Scenario:\n// A Text Editor (like Word or VS Code). Every time you type a letter, delete a word, or bold text,\n// that action is a \"Command\" object. This is why you can press \"Ctrl+Z\" (Undo) to reverse the\n// last command, because the editor remembers the history of commands you executed.\n\n// Command interface\ntype Command interface {\n\tExecute()\n}\n\n// Receiver (The TV)\ntype TV struct {\n\tIsOn bool\n}\n\nfunc (t *TV) On() {\n\tt.IsOn = true\n\tfmt.Println(\"TV is ON\")\n}\n\nfunc (t *TV) Off() {\n\tt.IsOn = false\n\tfmt.Println(\"TV is OFF\")\n}\n\n// -- Concrete Commands --\n\ntype TurnOnCommand struct {\n\ttv *TV\n}\n\nfunc (c *TurnOnCommand) Execute() {\n\tc.tv.On()\n}\n\ntype TurnOffCommand struct {\n\ttv *TV\n}\n\nfunc (c *TurnOffCommand) Execute() {\n\tc.tv.Off()\n}\n\n// Invoker (The Remote Button)\ntype RemoteButton struct {\n\tcommand Command\n}\n\nfunc (b *RemoteButton) Press() {\n\tb.command.Execute()\n}\n\nfunc main() {\n\tfmt.Println(\"--- Command Pattern: TV Remote ---\")\n\n\tmyTV := &TV{}\n\n\t// Setup commands\n\tonCommand := &TurnOnCommand{tv: myTV}\n\toffCommand := &TurnOffCommand{tv: myTV}\n\n\t// Create buttons\n\tonButton := &RemoteButton{command: onCommand}\n\toffButton := &RemoteButton{command: offCommand}\n\n\t// Press buttons\n\tfmt.Println(\"User presses ON button:\")\n\tonButton.Press()\n\n\tfmt.Println(\"User presses OFF button:\")\n\toffButton.Press()\n}\n"
          }
        ]
      },
      {
        "name": "observer",
        "type": "directory",
        "path": "design_patterns/behavioral/observer",
        "children": [
          {
            "name": "main.go",
            "type": "file",
            "path": "design_patterns/behavioral/observer/main.go",
            "content": "package main\n\nimport \"fmt\"\n\n// Observer Pattern\n//\n// 5-Year-Old Explanation:\n// Imagine a Newspaper Delivery.\n// The Newspaper Boy (Subject) has a list of houses (Observers).\n// When a new paper is ready, he goes to EVERY house on his list and throws the paper.\n// If you want the paper, you put your name on the list (Subscribe).\n// If you don't want it anymore, you take your name off (Unsubscribe).\n//\n// Real World Scenario:\n// YouTube or Newsletter Subscriptions. When a YouTuber uploads a new video, YouTube \"notifies\"\n// all millions of subscribers with a notification. The YouTuber (Subject) doesn't need to know\n// who you are, just that you are in the list of people to notify.\n\n// Observer interface\ntype Observer interface {\n\tUpdate(news string)\n}\n\n// Subject interface\ntype Subject interface {\n\tSubscribe(o Observer)\n\tUnsubscribe(o Observer)\n\tNotifyAll()\n}\n\n// -- Concrete Observer --\ntype Reader struct {\n\tName string\n}\n\nfunc (r *Reader) Update(news string) {\n\tfmt.Printf(\"%s recieved news: %s\\n\", r.Name, news)\n}\n\n// -- Concrete Subject --\ntype NewspaperAgency struct {\n\tsubscribers []Observer\n\tlatestNews  string\n}\n\nfunc (n *NewspaperAgency) Subscribe(o Observer) {\n\tn.subscribers = append(n.subscribers, o)\n\tfmt.Println(\"New subscriber added.\")\n}\n\nfunc (n *NewspaperAgency) Unsubscribe(o Observer) {\n\t// (Simplification: Removing from slice logic logic omitted for brevity in 5yo example,\n\t// but logically this removes them from the list)\n\tfmt.Println(\"Subscriber removed (pretend logic).\")\n}\n\nfunc (n *NewspaperAgency) NotifyAll() {\n\tfor _, sub := range n.subscribers {\n\t\tsub.Update(n.latestNews)\n\t}\n}\n\nfunc (n *NewspaperAgency) PublishNews(text string) {\n\tfmt.Printf(\"\\n--- Breaking News: %s ---\\n\", text)\n\tn.latestNews = text\n\tn.NotifyAll()\n}\n\nfunc main() {\n\tfmt.Println(\"--- Observer Pattern: Newspaper Delivery ---\")\n\n\tagency := &NewspaperAgency{}\n\n\t// People sign up\n\treader1 := &Reader{Name: \"Alice\"}\n\treader2 := &Reader{Name: \"Bob\"}\n\treader3 := &Reader{Name: \"Charlie\"}\n\n\tagency.Subscribe(reader1)\n\tagency.Subscribe(reader2)\n\tagency.Subscribe(reader3)\n\n\t// News happens!\n\tagency.PublishNews(\"Ice Cream is now FREE!\")\n\n\t// More news!\n\tagency.PublishNews(\"School is closed tomorrow!\")\n}\n"
          }
        ]
      },
      {
        "name": "state",
        "type": "directory",
        "path": "design_patterns/behavioral/state",
        "children": [
          {
            "name": "main.go",
            "type": "file",
            "path": "design_patterns/behavioral/state/main.go",
            "content": "package main\n\nimport \"fmt\"\n\n// State Pattern\n//\n// 5-Year-Old Explanation:\n// Imagine a Traffic Light.\n// It can be in different \"States\": GREEN, YELLOW, or RED.\n// When it is GREEN, cars GO.\n// When it is RED, cars STOP.\n// The light behaves DIFFERENTLY depending on what color (State) it is right now.\n//\n// Real World Scenario:\n// A Document Workflow (Draft -> Moderation -> Published).\n// When in \"Draft\" state, you can edit it.\n// When in \"Moderation\", you can't edit it, only Approve or Reject.\n// When \"Published\", it is public. The document behaves differently based on its current state.\n\ntype State interface {\n\tNext(light *TrafficLight)\n}\n\ntype TrafficLight struct {\n\tstate State\n}\n\nfunc (t *TrafficLight) SetState(s State) {\n\tt.state = s\n}\nfunc (t *TrafficLight) Change() {\n\tt.state.Next(t)\n}\n\n// -- Concrete States --\n\n// RedState\ntype RedState struct{}\n\nfunc (r *RedState) Next(t *TrafficLight) {\n\tfmt.Println(\"RED LIGHT: Stop! ... Changing to Green.\")\n\tt.SetState(&GreenState{})\n}\n\n// GreenState\ntype GreenState struct{}\n\nfunc (g *GreenState) Next(t *TrafficLight) {\n\tfmt.Println(\"GREEN LIGHT: Go! ... Changing to Yellow.\")\n\tt.SetState(&YellowState{})\n}\n\n// YellowState\ntype YellowState struct{}\n\nfunc (y *YellowState) Next(t *TrafficLight) {\n\tfmt.Println(\"YELLOW LIGHT: Slow down! ... Changing to Red.\")\n\tt.SetState(&RedState{})\n}\n\nfunc main() {\n\tfmt.Println(\"--- State Pattern: Traffic Light ---\")\n\n\t// Start with Green\n\tlight := &TrafficLight{state: &GreenState{}}\n\n\t// Cycle through steps\n\tfor i := 0; i < 6; i++ {\n\t\tlight.Change()\n\t}\n}\n"
          }
        ]
      },
      {
        "name": "strategy",
        "type": "directory",
        "path": "design_patterns/behavioral/strategy",
        "children": [
          {
            "name": "main.go",
            "type": "file",
            "path": "design_patterns/behavioral/strategy/main.go",
            "content": "package main\n\nimport \"fmt\"\n\n// Strategy Pattern\n//\n// 5-Year-Old Explanation:\n// Imagine you want to go to the park.\n// You can choose DIFFERENT ways to get there:\n// 1. Walk (Slow but free)\n// 2. Bike (Faster)\n// 3. Car (Super fast but needs gas)\n// The \"Strategy\" is just \"How do we get there?\".\n// You can pick a different strategy depending on if you are in a rush!\n//\n// Real World Scenario:\n// Saving a file. You might have a \"SaveStrategy\".\n// - SaveToLocalDisk (for offline use)\n// - SaveToS3 (cloud storage)\n// - SaveToDatabase (binary data)\n// The application just says \"Save(file)\", and the specific Strategy handles WHERE it goes.\n\n// TravelStrategy is the interface for our travel method.\ntype TravelStrategy interface {\n\tTravel(destination string)\n}\n\n// -- Concrete Strategies --\n\n// WalkStrategy\ntype WalkStrategy struct{}\n\nfunc (w *WalkStrategy) Travel(destination string) {\n\tfmt.Printf(\"Walking to %s. It will take a long time, but it's healthy!\\n\", destination)\n}\n\n// CarStrategy\ntype CarStrategy struct{}\n\nfunc (c *CarStrategy) Travel(destination string) {\n\tfmt.Printf(\"Driving to %s. Vroom! We'll be there fast!\\n\", destination)\n}\n\n// BusStrategy\ntype BusStrategy struct{}\n\nfunc (b *BusStrategy) Travel(destination string) {\n\tfmt.Printf(\"Taking the bus to %s. We sit with other people!\\n\", destination)\n}\n\n// -- The Context (The Traveler) --\ntype Traveler struct {\n\tstrategy TravelStrategy\n}\n\nfunc (t *Traveler) SetStrategy(s TravelStrategy) {\n\tt.strategy = s\n}\nfunc (t *Traveler) GoTo(destination string) {\n\tt.strategy.Travel(destination)\n}\n\nfunc main() {\n\tfmt.Println(\"--- Strategy Pattern: Choosing How to Travel ---\")\n\n\tme := &Traveler{}\n\n\t// 1. I have time, let's walk\n\tfmt.Println(\"\\nSituation 1: Sunny day, plenty of time.\")\n\tme.SetStrategy(&WalkStrategy{})\n\tme.GoTo(\"The Park\")\n\n\t// 2. I'm late! Take the car!\n\tfmt.Println(\"\\nSituation 2: I'm LATE!\")\n\tme.SetStrategy(&CarStrategy{})\n\tme.GoTo(\"The Airport\")\n\n\t// 3. Car broke down, take the bus\n\tfmt.Println(\"\\nSituation 3: Car won't start.\")\n\tme.SetStrategy(&BusStrategy{})\n\tme.GoTo(\"School\")\n}\n"
          }
        ]
      }
    ]
  },
  {
    "name": "concurrency",
    "type": "directory",
    "path": "design_patterns/concurrency",
    "children": [
      {
        "name": "fan_out_fan_in",
        "type": "directory",
        "path": "design_patterns/concurrency/fan_out_fan_in",
        "children": [
          {
            "name": "main.go",
            "type": "file",
            "path": "design_patterns/concurrency/fan_out_fan_in/main.go",
            "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\n// Fan-Out / Fan-In Pattern\n//\n// 5-Year-Old Explanation:\n// Fan-Out (Splitting): Imagine you have a bag of candy to wrap.\n// You give a handful to Friend A, a handful to Friend B, and a handful to Friend C.\n// They all wrap candy at the same time (Fan-Out).\n//\n// Fan-In (Collecting): When they are done, they all put the wrapped candy back into ONE big bowl.\n// You collect everything from everyone into one place (Fan-In).\n//\n// Real World Scenario:\n// Image Processing. You have 1000 images to resize.\n// Fan-Out: You spin up 10 workers, each taking 100 images to resize in parallel.\n// Fan-In: As they finish, they all send the resized images to a single channel to be zipped into a file.\n\n// Worker: Wraps the candy (Multiplies number by 10)\nfunc CandyWrapper(id int, input <-chan int) <-chan int {\n\tout := make(chan int)\n\tgo func() {\n\t\tfor n := range input {\n\t\t\tfmt.Printf(\"Friend %d wrapping candy %d...\\n\", id, n)\n\t\t\tout <- n * 10 // \"Wrapped\"\n\t\t}\n\t\tclose(out)\n\t}()\n\treturn out\n}\n\n// Fan-In: Collects from multiple channels into one\nfunc Merge(channels ...<-chan int) <-chan int {\n\tvar wg sync.WaitGroup\n\tout := make(chan int)\n\n\t// Function to copy from one channel to the output\n\toutput := func(c <-chan int) {\n\t\tfor n := range c {\n\t\t\tout <- n\n\t\t}\n\t\twg.Done()\n\t}\n\n\twg.Add(len(channels))\n\tfor _, c := range channels {\n\t\tgo output(c)\n\t}\n\n\t// Wait for everyone to finish, then close the output\n\tgo func() {\n\t\twg.Wait()\n\t\tclose(out)\n\t}()\n\treturn out\n}\n\nfunc main() {\n\tfmt.Println(\"--- Fan-Out/Fan-In: Candy Wrapping Party ---\")\n\n\t// 1. The input (Bag of candy)\n\tcandyBag := make(chan int)\n\tgo func() {\n\t\tfor i := 1; i <= 10; i++ {\n\t\t\tcandyBag <- i\n\t\t}\n\t\tclose(candyBag)\n\t}()\n\n\t// 2. Fan-Out: Give work to 3 friends\n\tfriend1 := CandyWrapper(1, candyBag)\n\tfriend2 := CandyWrapper(2, candyBag)\n\tfriend3 := CandyWrapper(3, candyBag)\n\n\t// 3. Fan-In: Collect all wrapped candy into one bowl\n\tfinalBowl := Merge(friend1, friend2, friend3)\n\n\t// 4. Look at the result\n\tfmt.Println(\"\\nChecking the bowl:\")\n\tcount := 0\n\tfor c := range finalBowl {\n\t\tfmt.Printf(\"Got wrapped candy: %d\\n\", c)\n\t\tcount++\n\t}\n\tfmt.Printf(\"Total candies wrapped: %d\\n\", count)\n}\n"
          }
        ]
      },
      {
        "name": "pipeline",
        "type": "directory",
        "path": "design_patterns/concurrency/pipeline",
        "children": [
          {
            "name": "main.go",
            "type": "file",
            "path": "design_patterns/concurrency/pipeline/main.go",
            "content": "package main\n\nimport \"fmt\"\n\n// Pipeline Pattern\n//\n// 5-Year-Old Explanation:\n// Imagine a factory line making Cakes.\n// It happens in steps:\n// Step 1: Someone puts dough in a pan (Generator).\n// Step 2: Someone bakes it (Stage 1).\n// Step 3: Someone puts icing on it (Stage 2).\n// Step 4: Someone puts a cherry on top (Stage 3).\n// The cake moves from person to person.\n// While the Baker is baking Cake #1, the Generator is already preparing Cake #2!\n//\n// Real World Scenario:\n// Data Processing ETL (Extract, Transform, Load).\n// Stage 1: Read lines from a huge log file (Extract).\n// Stage 2: Parse the JSON and filter errors (Transform).\n// Stage 3: Write the errors to a database (Load).\n// Each stage runs in parallel, passing data to the next stage instantly.\n\n// 1. Generator: Converts a list of numbers into a channel\nfunc Generator(nums ...int) <-chan int {\n\tout := make(chan int)\n\tgo func() {\n\t\tfor _, n := range nums {\n\t\t\tout <- n\n\t\t}\n\t\tclose(out)\n\t}()\n\treturn out\n}\n\n// 2. Square Stage: Takes a number, squares it, passes it on\nfunc Square(in <-chan int) <-chan int {\n\tout := make(chan int)\n\tgo func() {\n\t\tfor n := range in {\n\t\t\tresult := n * n\n\t\t\tfmt.Printf(\"Square Stage: %d * %d = %d\\n\", n, n, result)\n\t\t\tout <- result\n\t\t}\n\t\tclose(out)\n\t}()\n\treturn out\n}\n\n// 3. AddOne Stage: Takes a number, adds 1, passes it on\nfunc AddOne(in <-chan int) <-chan int {\n\tout := make(chan int)\n\tgo func() {\n\t\tfor n := range in {\n\t\t\tresult := n + 1\n\t\t\tfmt.Printf(\"AddOne Stage: %d + 1 = %d\\n\", n, result)\n\t\t\tout <- result\n\t\t}\n\t\tclose(out)\n\t}()\n\treturn out\n}\n\nfunc main() {\n\tfmt.Println(\"--- Pipeline Pattern: The Number Factory ---\")\n\n\t// Set up the assembly line\n\t// Numbers -> [Generator] -> [Square] -> [AddOne] -> Output\n\n\t// Step 1: Input\n\tinput := Generator(1, 2, 3, 4)\n\n\t// Step 2: Square it\n\tstage1 := Square(input)\n\n\t// Step 3: Add one\n\tstage2 := AddOne(stage1)\n\n\t// Consume the final output\n\tfmt.Println(\"\\nCollecting Final Results:\")\n\tfor result := range stage2 {\n\t\tfmt.Printf(\"Final Result: %d\\n\", result)\n\t}\n}\n"
          }
        ]
      },
      {
        "name": "worker_pool",
        "type": "directory",
        "path": "design_patterns/concurrency/worker_pool",
        "children": [
          {
            "name": "main.go",
            "type": "file",
            "path": "design_patterns/concurrency/worker_pool/main.go",
            "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\n// Worker Pool Pattern\n//\n// 5-Year-Old Explanation:\n// Imagine you have a BIG pile of bricks to move.\n// You could do it all by yourself, but it would take forever!\n// Instead, you hire a TEAM of 3 workers.\n// You stand there and point: \"You move this brick! You move that brick!\"\n// The workers grab bricks from the pile as fast as they can until the pile is gone.\n// 3 people working is much faster than 1!\n//\n// Real World Scenario:\n// Handling HTTP Requests. A web server receives 10,000 requests per second.\n// Creating 10,000 threads would kill the server (Out of Memory).\n// Instead, you have a \"Worker Pool\" of 50 workers.\n// The requests go into a queue, and the 50 workers pick them up one by one.\n\n// Worker is a person who does the job.\nfunc Worker(id int, jobs <-chan int, results chan<- int) {\n\t// The worker keeps watching the \"jobs\" pile.\n\tfor j := range jobs {\n\t\tfmt.Printf(\"Worker %d started job %d\\n\", id, j)\n\t\ttime.Sleep(time.Millisecond * 500) // Pretend work takes time\n\t\tfmt.Printf(\"Worker %d finished job %d\\n\", id, j)\n\t\tresults <- j * 2 // Send the result back\n\t}\n}\n\nfunc main() {\n\tfmt.Println(\"--- Worker Pool: The Construction Team ---\")\n\n\tconst numJobs = 5\n\n\t// 1. Make a channel for jobs (The pile of bricks)\n\tjobs := make(chan int, numJobs)\n\n\t// 2. Make a channel for results (The finished wall)\n\tresults := make(chan int, numJobs)\n\n\t// 3. Hire 3 workers\n\t// We start them immediately, but they will wait until there are jobs.\n\tfor w := 1; w <= 3; w++ {\n\t\tgo Worker(w, jobs, results)\n\t}\n\n\t// 4. Assign jobs (Put bricks in the pile)\n\tfor j := 1; j <= numJobs; j++ {\n\t\tfmt.Println(\"Manager: Adding job\", j)\n\t\tjobs <- j\n\t}\n\tclose(jobs) // \"That's all the work for today!\"\n\n\t// 5. Collect results\n\tfor a := 1; a <= numJobs; a++ {\n\t\t<-results\n\t}\n\n\tfmt.Println(\"All jobs finished!\")\n}\n"
          }
        ]
      }
    ]
  },
  {
    "name": "creational",
    "type": "directory",
    "path": "design_patterns/creational",
    "children": [
      {
        "name": "abstract_factory",
        "type": "directory",
        "path": "design_patterns/creational/abstract_factory",
        "children": [
          {
            "name": "main.go",
            "type": "file",
            "path": "design_patterns/creational/abstract_factory/main.go",
            "content": "package main\n\nimport \"fmt\"\n\n// Abstract Factory Pattern\n//\n// 5-Year-Old Explanation:\n// Imagine two furniture stores: one sells \"Modern\" stuff (cool and new),\n// and the other sells \"Old-Fashioned\" stuff (fancy and classic).\n// If you go to the \"Modern Store\", EVERY piece of furniture you buy (chair, sofa) matches the modern style.\n// If you go to the \"Old-Fashioned Store\", EVERYTHING matches the old style.\n// You don't mix and match by accident!\n//\n// Real World Scenario:\n// Building UI libraries where you need a \"Dark Theme\" factory and a \"Light Theme\" factory.\n// The \"Dark Theme\" factory creates dark buttons and dark windows, while the \"Light Theme\"\n// factory creates light buttons and windows. You never want to mix a dark button with a light window.\n\n// Chair interface\ntype Chair interface {\n\tSit()\n}\n\n// Sofa interface\ntype Sofa interface {\n\tLieDown()\n}\n\n// --- Modern Furniture ---\ntype ModernChair struct{}\n\nfunc (m *ModernChair) Sit() { fmt.Println(\"Sitting on a cool Modern Chair.\") }\n\ntype ModernSofa struct{}\n\nfunc (m *ModernSofa) LieDown() { fmt.Println(\"Sleeping on a cool Modern Sofa.\") }\n\n// --- Old-Fashioned (Victorian) Furniture ---\ntype VictorianChair struct{}\n\nfunc (v *VictorianChair) Sit() { fmt.Println(\"Sitting on a fancy Victorian Chair.\") }\n\ntype VictorianSofa struct{}\n\nfunc (v *VictorianSofa) LieDown() { fmt.Println(\"Sleeping on a fancy Victorian Sofa.\") }\n\n// --- The Factory Interface ---\n// This tells us what any furniture factory MUST be able to make.\ntype FurnitureFactory interface {\n\tCreateChair() Chair\n\tCreateSofa() Sofa\n}\n\n// --- Concrete Factories ---\n\n// ModernFactory only makes Modern stuff\ntype ModernFactory struct{}\n\nfunc (m *ModernFactory) CreateChair() Chair { return &ModernChair{} }\nfunc (m *ModernFactory) CreateSofa() Sofa   { return &ModernSofa{} }\n\n// VictorianFactory only makes Victorian stuff\ntype VictorianFactory struct{}\n\nfunc (v *VictorianFactory) CreateChair() Chair { return &VictorianChair{} }\nfunc (v *VictorianFactory) CreateSofa() Sofa   { return &VictorianSofa{} }\n\nfunc main() {\n\tfmt.Println(\"--- Abstract Factory Pattern: Matching Furniture Sets ---\")\n\n\t// Let's buy a Modern set!\n\tfmt.Println(\"\\nVisiting the Modern Store...\")\n\tvar modernFactory FurnitureFactory = &ModernFactory{}\n\tchair1 := modernFactory.CreateChair()\n\tsofa1 := modernFactory.CreateSofa()\n\tchair1.Sit()\n\tsofa1.LieDown()\n\n\t// Let's buy a Victorian set!\n\tfmt.Println(\"\\nVisiting the Victorian Store...\")\n\tvar oldFactory FurnitureFactory = &VictorianFactory{}\n\tchair2 := oldFactory.CreateChair()\n\tsofa2 := oldFactory.CreateSofa()\n\tchair2.Sit()\n\tsofa2.LieDown()\n}\n"
          }
        ]
      },
      {
        "name": "builder",
        "type": "directory",
        "path": "design_patterns/creational/builder",
        "children": [
          {
            "name": "main.go",
            "type": "file",
            "path": "design_patterns/creational/builder/main.go",
            "content": "package main\n\nimport \"fmt\"\n\n// Builder Pattern\n//\n// 5-Year-Old Explanation:\n// Imagine you are building a LEGO castle.\n// You don't just \"poof\" a whole castle into existence.\n// You build it step-by-step:\n// 1. First, you build the walls.\n// 2. Then, you add a roof.\n// 3. Maybe you add a moat (water) around it.\n// The Builder lets you choose exactly what parts you want!\n//\n// Real World Scenario:\n// Constructing a complex SQL query or a customized HTTP request. You start with a base request\n// and then optionally add headers, a body, query parameters, or timeouts step-by-step before\n// finally \"building\" and sending the request.\n\n// Castle is the complex object we are building.\ntype Castle struct {\n\tWalls string\n\tRoof  string\n\tMoat  string\n}\n\n// Show tells us what our castle looks like.\nfunc (c *Castle) Show() {\n\tfmt.Printf(\"Castle details: Walls=[%s], Roof=[%s], Moat=[%s]\\n\", c.Walls, c.Roof, c.Moat)\n}\n\n// CastleBuilder helps us build the castle step-by-step.\ntype CastleBuilder struct {\n\tcastle Castle\n}\n\nfunc NewCastleBuilder() *CastleBuilder {\n\treturn &CastleBuilder{}\n}\n\n// BuildWalls adds walls to our castle.\nfunc (b *CastleBuilder) BuildWalls(style string) *CastleBuilder {\n\tb.castle.Walls = style\n\treturn b\n}\n\n// BuildRoof adds a roof.\nfunc (b *CastleBuilder) BuildRoof(style string) *CastleBuilder {\n\tb.castle.Roof = style\n\treturn b\n}\n\n// BuildMoat adds a moat.\nfunc (b *CastleBuilder) BuildMoat(typeOfMoat string) *CastleBuilder {\n\tb.castle.Moat = typeOfMoat\n\treturn b\n}\n\n// GetResult returns the finished castle.\nfunc (b *CastleBuilder) GetResult() Castle {\n\treturn b.castle\n}\n\nfunc main() {\n\tfmt.Println(\"--- Builder Pattern: Building a Lego Castle ---\")\n\n\t// Builder 1: A simple castle\n\tfmt.Println(\"\\nBuilder 1 making a simple castle...\")\n\tbuilder1 := NewCastleBuilder()\n\tcastle1 := builder1.BuildWalls(\"Stone\").BuildRoof(\"Wood\").GetResult()\n\tcastle1.Show()\n\n\t// Builder 2: A super fancy castle!\n\tfmt.Println(\"\\nBuilder 2 making a SUPER fancy castle...\")\n\tbuilder2 := NewCastleBuilder()\n\tcastle2 := builder2.\n\t\tBuildWalls(\"Diamond\").\n\t\tBuildRoof(\"Gold\").\n\t\tBuildMoat(\"Lava\").\n\t\tGetResult()\n\tcastle2.Show()\n}\n"
          }
        ]
      },
      {
        "name": "factory_method",
        "type": "directory",
        "path": "design_patterns/creational/factory_method",
        "children": [
          {
            "name": "main.go",
            "type": "file",
            "path": "design_patterns/creational/factory_method/main.go",
            "content": "package main\n\nimport \"fmt\"\n\n// Factory Method Pattern\n//\n// 5-Year-Old Explanation:\n// Imagine a magical Toy Factory. You don't need to know how to build a car or a doll.\n// You just go to the factory window and say \"I want a car!\" or \"I want a doll!\".\n// The factory hands you the toy, ready to play!\n//\n// Real World Scenario:\n// A payment processing system. You have a processPayment method, but based on the user's choice\n// (Credit Card, PayPal, Bitcoin), you need to create a specific PaymentProcessor object\n// (like CreditCardProcessor or PayPalProcessor) to handle the transaction.\n\n// Toy is something we can play with.\ntype Toy interface {\n\tPlay()\n}\n\n// Car is a type of Toy.\ntype Car struct{}\n\nfunc (c *Car) Play() {\n\tfmt.Println(\"Car says: Vroom Vroom! ðŸš—\")\n}\n\n// Doll is another type of Toy.\ntype Doll struct{}\n\nfunc (d *Doll) Play() {\n\tfmt.Println(\"Doll says: Hello, let's have tea! ðŸ§¸\")\n}\n\n// ToyFactory is where we ask for new toys.\nfunc MakeToy(toyType string) Toy {\n\tswitch toyType {\n\tcase \"car\":\n\t\treturn &Car{}\n\tcase \"doll\":\n\t\treturn &Doll{}\n\tdefault:\n\t\treturn nil\n\t}\n}\n\nfunc main() {\n\tfmt.Println(\"--- Factory Method Pattern: The Magic Toy Factory ---\")\n\n\t// I want a car!\n\tfmt.Println(\"Kid: Can I have a car?\")\n\tmyToy1 := MakeToy(\"car\")\n\tmyToy1.Play()\n\n\t// I want a doll!\n\tfmt.Println(\"Kid: Can I have a doll?\")\n\tmyToy2 := MakeToy(\"doll\")\n\tmyToy2.Play()\n}\n"
          }
        ]
      },
      {
        "name": "functional_options",
        "type": "directory",
        "path": "design_patterns/creational/functional_options",
        "children": [
          {
            "name": "main.go",
            "type": "file",
            "path": "design_patterns/creational/functional_options/main.go",
            "content": "package main\n\nimport \"fmt\"\n\n// Functional Options Pattern\n//\n// 5-Year-Old Explanation:\n// Imagine you are ordering a Pizza.\n// Every pizza starts with just dough and tomato sauce (The Base).\n// But you can choose to ADD extra things if you want!\n// \"Add Cheese please!\"\n// \"Add Pepperoni please!\"\n// You don't HAVE to add them, but you CAN if you want to.\n//\n// Real World Scenario:\n// Configuring a Server (like an HTTP server). You start with a default server configuration.\n// Then, you can use options like WithPort(8080), WithTimeout(30s), or WithLogger(myLogger)\n// to customize it. This is cleaner than having a constructor with 10 different arguments.\n\n// Pizza is what we are making.\ntype Pizza struct {\n\tDough    string\n\tSauce    string\n\tCheese   bool\n\tToppings []string\n}\n\n// PizzaOption is a function that changes the Pizza.\n// It's like a special instruction card you give to the chef.\ntype PizzaOption func(*Pizza)\n\n// NewPizza makes a basic pizza, then applies any extra options you asked for.\nfunc NewPizza(opts ...PizzaOption) *Pizza {\n\t// Start with the default \"Basic\" pizza\n\tp := &Pizza{\n\t\tDough:    \"Regular\",\n\t\tSauce:    \"Tomato\",\n\t\tCheese:   false, // Default is no extra cheese\n\t\tToppings: []string{},\n\t}\n\n\t// Apply all the options (instructions) one by one\n\tfor _, opt := range opts {\n\t\topt(p)\n\t}\n\n\treturn p\n}\n\n// WithExtraCheese is an option to add cheese.\nfunc WithExtraCheese() PizzaOption {\n\treturn func(p *Pizza) {\n\t\tp.Cheese = true\n\t}\n}\n\n// WithTopping is an option to add a specific topping.\nfunc WithTopping(topping string) PizzaOption {\n\treturn func(p *Pizza) {\n\t\tp.Toppings = append(p.Toppings, topping)\n\t}\n}\n\nfunc main() {\n\tfmt.Println(\"--- Functional Options Pattern: Ordering Pizza ---\")\n\n\t// 1. A Plain Pizza (No options)\n\tfmt.Println(\"\\nOrder 1: Plain Pizza\")\n\tpizza1 := NewPizza()\n\tfmt.Printf(\"Pizza 1: %+v\\n\", pizza1)\n\n\t// 2. A Cheese Pizza with Pepperoni\n\tfmt.Println(\"\\nOrder 2: Cheese + Pepperoni\")\n\tpizza2 := NewPizza(\n\t\tWithExtraCheese(),\n\t\tWithTopping(\"Pepperoni\"),\n\t)\n\tfmt.Printf(\"Pizza 2: %+v\\n\", pizza2)\n\n\t// 3. The \"Everything\" Pizza\n\tfmt.Println(\"\\nOrder 3: The Works!\")\n\tpizza3 := NewPizza(\n\t\tWithExtraCheese(),\n\t\tWithTopping(\"Mushrooms\"),\n\t\tWithTopping(\"Olives\"),\n\t\tWithTopping(\"Onions\"),\n\t)\n\tfmt.Printf(\"Pizza 3: %+v\\n\", pizza3)\n}\n"
          }
        ]
      },
      {
        "name": "prototype",
        "type": "directory",
        "path": "design_patterns/creational/prototype",
        "children": [
          {
            "name": "main.go",
            "type": "file",
            "path": "design_patterns/creational/prototype/main.go",
            "content": "package main\n\nimport \"fmt\"\n\n// Prototype Pattern\n//\n// 5-Year-Old Explanation:\n// Imagine you drew a perfect picture of a robot.\n// If your friend wants the SAME robot, you don't have to draw it all over again from scratch.\n// You can just put your drawing in a photocopy machine and press \"COPY\"!\n// Now you have two robots!\n//\n// Real World Scenario:\n// Game development. Spawning hordes of enemies (e.g., \"Goblins\"). Instead of creating a new\n// Goblin object from scratch (loading textures, sounds, stats) every single time, you create one\n// \"Master Goblin\" and just \"clone\" it 100 times, maybe tweaking their position or HP slightly.\n\n// Robot is our prototype interface.\ntype Robot interface {\n\tClone() Robot\n\tSayVal() string\n}\n\n// BlueRobot is a specific type of robot.\ntype BlueRobot struct {\n\tName  string\n\tPower int\n}\n\n// Clone creates a copy of the BlueRobot.\nfunc (r *BlueRobot) Clone() Robot {\n\t// We create a NEW BlueRobot and copy the values over.\n\treturn &BlueRobot{\n\t\tName:  r.Name + \"_Clone\", // Adding \"_Clone\" just so we can see it's a copy\n\t\tPower: r.Power,\n\t}\n}\n\nfunc (r *BlueRobot) SayVal() string {\n\treturn fmt.Sprintf(\"I am %s and my power is %d\", r.Name, r.Power)\n}\n\nfunc main() {\n\tfmt.Println(\"--- Prototype Pattern: Cloning Robots ---\")\n\n\t// 1. Create the original robot\n\toriginalRobot := &BlueRobot{Name: \"Robo-One\", Power: 100}\n\tfmt.Println(\"Original:\", originalRobot.SayVal())\n\n\t// 2. Clone it! (Hit the copy button)\n\tclonedRobot := originalRobot.Clone()\n\tfmt.Println(\"Clone:   \", clonedRobot.SayVal())\n\n\t// Prove they are different objects\n\tfmt.Printf(\"\\n(Proof: Original is at address %p, Clone is at address %p)\\n\", originalRobot, clonedRobot)\n}\n"
          }
        ]
      },
      {
        "name": "singleton",
        "type": "directory",
        "path": "design_patterns/creational/singleton",
        "children": [
          {
            "name": "main.go",
            "type": "file",
            "path": "design_patterns/creational/singleton/main.go",
            "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\n// Singleton Pattern\n//\n// 5-Year-Old Explanation:\n// Imagine a country can only have ONE President.\n// No matter how many people ask \"Who is the President?\", they should all get the SAME answer.\n// You can't have two Presidents at the same time!\n//\n// Real World Scenario:\n// Database connection pool or a Logger service. You typically only want ONE database connection\n// pool for your entire application to manage resources efficiently. If every part of your code\n// created its own connection pool, you'd crash the database.\n\n// president is our private struct. No one can make a new one directly.\ntype president struct {\n\tname string\n}\n\n// instance is the ONE and ONLY instance of president we will ever have.\nvar instance *president\n\n// once is a special tool (\"magic lock\") that makes sure we only create the president ONCE.\nvar once sync.Once\n\n// GetPresident is the way to reach the President.\nfunc GetPresident() *president {\n\t// once.Do makes sure that the code inside it runs only ONE time,\n\t// even if a million people call GetPresident at the same time.\n\tonce.Do(func() {\n\t\tfmt.Println(\"Creating the President for the very first time!\")\n\t\tinstance = &president{name: \"Mr. Gopher\"}\n\t})\n\treturn instance\n}\n\nfunc main() {\n\tfmt.Println(\"--- Singleton Pattern: The One and Only President ---\")\n\n\t// First person asks for the President\n\tfmt.Println(\"Person 1: calls GetPresident()\")\n\tp1 := GetPresident()\n\tfmt.Printf(\"Person 1 sees President: %s\\n\", p1.name)\n\n\t// Second person asks for the President\n\tfmt.Println(\"Person 2: calls GetPresident()\")\n\tp2 := GetPresident()\n\tfmt.Printf(\"Person 2 sees President: %s\\n\", p2.name)\n\n\t// Let's check if they are the SAME president\n\tif p1 == p2 {\n\t\tfmt.Println(\"Result: They are the SAME President! (Works as expected)\")\n\t} else {\n\t\tfmt.Println(\"Result: They are DIFFERENT! (Something is wrong)\")\n\t}\n}\n"
          }
        ]
      }
    ]
  },
  {
    "name": "structural",
    "type": "directory",
    "path": "design_patterns/structural",
    "children": [
      {
        "name": "adapter",
        "type": "directory",
        "path": "design_patterns/structural/adapter",
        "children": [
          {
            "name": "main.go",
            "type": "file",
            "path": "design_patterns/structural/adapter/main.go",
            "content": "package main\n\nimport \"fmt\"\n\n// Adapter Pattern\n//\n// 5-Year-Old Explanation:\n// Imagine you are traveling to a different country.\n// Your phone charger has a square plug, but the wall socket only takes round plugs!\n// You can't plug it in directly.\n// You need an \"Adapter\" (a special connector) that changes your square plug into a round one.\n// Now you can charge your phone!\n//\n// Real World Scenario:\n// Integrating a legacy system with a modern one.\n// The new system expects data in JSON format, but the old legacy system gives data in XML.\n// You create an \"XMLtoJSONAdapter\" so the new system can use the old data without crashing.\n\n// -- The \"Client\" (What we want to use) --\ntype Computer interface {\n\tInsertSquareUSB()\n}\n\n// Mac is a computer that accepts square USBs.\ntype Mac struct{}\n\nfunc (m *Mac) InsertSquareUSB() {\n\tfmt.Println(\"Success: Square USB connected to Mac.\")\n}\n\n// -- The \"Service\" (What we have, but it doesn't fit) --\ntype WindowsMachine struct{}\n\nfunc (w *WindowsMachine) InsertRoundUSB() {\n\tfmt.Println(\"Success: Round USB connected to Windows Machine.\")\n}\n\n// -- The Adapter --\n// WindowsAdapter makes a WindowsMachine look like a Computer (Mac-style input).\ntype WindowsAdapter struct {\n\twindowMachine *WindowsMachine\n}\n\nfunc (w *WindowsAdapter) InsertSquareUSB() {\n\tfmt.Println(\"Adapter: Converting Square USB signal to Round USB...\")\n\tw.windowMachine.InsertRoundUSB()\n}\n\nfunc main() {\n\tfmt.Println(\"--- Adapter Pattern: The Power Plug Converter ---\")\n\n\t// 1. Using a Mac directly (Fits perfectly)\n\tfmt.Println(\"\\nUser: I have a Mac.\")\n\tmac := &Mac{}\n\tmac.InsertSquareUSB()\n\n\t// 2. Trying to use a Windows Machine with a Square USB\n\tfmt.Println(\"\\nUser: I have a Windows Machine, but my cable is Square!\")\n\twindowsMachine := &WindowsMachine{}\n\n\t// We need an adapter!\n\tadapter := &WindowsAdapter{\n\t\twindowMachine: windowsMachine,\n\t}\n\n\t// Now we can use the \"Square USB\" method on the adapter\n\tfmt.Println(\"User: Pugging Square cable into Adapter...\")\n\tadapter.InsertSquareUSB()\n}\n"
          }
        ]
      },
      {
        "name": "bridge",
        "type": "directory",
        "path": "design_patterns/structural/bridge",
        "children": [
          {
            "name": "main.go",
            "type": "file",
            "path": "design_patterns/structural/bridge/main.go",
            "content": "package main\n\nimport \"fmt\"\n\n// Bridge Pattern\n//\n// 5-Year-Old Explanation:\n// Imagine you have a TV Remote and a TV.\n// The Remote (the clicker) is one thing. The TV (the screen) is another thing.\n// You can have different kinds of Remotes (Basic, Fancy) and different kinds of TVs (Sony, Samsung).\n// The Bridge pattern separates the \"Remote\" from the \"TV\" so you can mix and match them!\n// A Fancy Remote can work with a Sony TV OR a Samsung TV.\n//\n// Real World Scenario:\n// Universal Remote Controls or Cross-Platform GUI toolkits.\n// You have the \"Window\" abstraction (Window, Dialog, Panel) and the \"OS Implementation\" (Windows, Linux, Mac).\n// The Bridge allows you to develop the Window logic independently of the OS rendering logic.\n\n// -- Implementation (The Device/TV) --\ntype Device interface {\n\tRun()\n\tIsEnabled() bool\n\tEnable()\n\tDisable()\n\tSetVolume(percent int)\n}\n\n// Tv is a specific device\ntype Tv struct {\n\ton     bool\n\tvolume int\n}\n\nfunc (t *Tv) Run() {\n\tfmt.Println(\"TV is running...\")\n}\n\nfunc (t *Tv) IsEnabled() bool {\n\treturn t.on\n}\n\nfunc (t *Tv) Enable() {\n\tfmt.Println(\"TV: Turned ON\")\n\tt.on = true\n}\n\nfunc (t *Tv) Disable() {\n\tfmt.Println(\"TV: Turned OFF\")\n\tt.on = false\n}\n\nfunc (t *Tv) SetVolume(percent int) {\n\tt.volume = percent\n\tfmt.Printf(\"TV: Volume set to %d\\n\", t.volume)\n}\n\n// Radio is another device\ntype Radio struct {\n\ton     bool\n\tvolume int\n}\n\nfunc (r *Radio) Run() {\n\tfmt.Println(\"Radio is playing music...\")\n}\n\nfunc (r *Radio) IsEnabled() bool {\n\treturn r.on\n}\n\nfunc (r *Radio) Enable() {\n\tfmt.Println(\"Radio: Turned ON\")\n\tr.on = true\n}\n\nfunc (r *Radio) Disable() {\n\tfmt.Println(\"Radio: Turned OFF\")\n\tr.on = false\n}\n\nfunc (r *Radio) SetVolume(percent int) {\n\tr.volume = percent\n\tfmt.Printf(\"Radio: Volume set to %d\\n\", r.volume)\n}\n\n// -- Abstraction (The Remote) --\ntype RemoteControl interface {\n\tTogglePower()\n\tVolumeDown()\n\tVolumeUp()\n}\n\n// BasicRemote is a simple remote\ntype BasicRemote struct {\n\tdevice Device\n}\n\nfunc (r *BasicRemote) TogglePower() {\n\tfmt.Println(\"Remote: Power button pressed.\")\n\tif r.device.IsEnabled() {\n\t\tr.device.Disable()\n\t} else {\n\t\tr.device.Enable()\n\t}\n}\n\nfunc (r *BasicRemote) VolumeDown() {\n\tfmt.Println(\"Remote: Volume Down pressed.\")\n\tr.device.SetVolume(0)\n}\n\nfunc (r *BasicRemote) VolumeUp() {\n\tfmt.Println(\"Remote: Volume Up pressed.\")\n\tr.device.SetVolume(100)\n}\n\n// AdvancedRemote can do more (mute)\ntype AdvancedRemote struct {\n\tBasicRemote // Inherits from BasicRemote\n}\n\nfunc (r *AdvancedRemote) Mute() {\n\tfmt.Println(\"Advanced Remote: Mute pressed.\")\n\tr.device.SetVolume(0)\n}\n\nfunc main() {\n\tfmt.Println(\"--- Bridge Pattern: Remote and Devices ---\")\n\n\ttestDevice := func(device Device) {\n\t\tfmt.Println(\"Tests with Basic Remote.\")\n\t\tbasicRemote := BasicRemote{device: device}\n\t\tbasicRemote.TogglePower()\n\t\tbasicRemote.VolumeUp()\n\t\tbasicRemote.TogglePower()\n\n\t\tfmt.Println(\"\\nTests with Advanced Remote.\")\n\t\tadvancedRemote := AdvancedRemote{BasicRemote{device: device}}\n\t\tadvancedRemote.TogglePower()\n\t\tadvancedRemote.Mute()\n\t\tadvancedRemote.TogglePower()\n\t}\n\n\tfmt.Println(\"\\n--> Connecting to TV\")\n\ttv := &Tv{}\n\ttestDevice(tv)\n\n\tfmt.Println(\"\\n--> Connecting to Radio\")\n\tradio := &Radio{}\n\ttestDevice(radio)\n}\n"
          }
        ]
      },
      {
        "name": "composite",
        "type": "directory",
        "path": "design_patterns/structural/composite",
        "children": [
          {
            "name": "main.go",
            "type": "file",
            "path": "design_patterns/structural/composite/main.go",
            "content": "package main\n\nimport \"fmt\"\n\n// Composite Pattern\n//\n// 5-Year-Old Explanation:\n// Imagine a big box of toys.\n// Inside the box, you can have a loose toy (like a car).\n// OR you can have ANOTHER box inside it, which has more toys!\n// Whether you look at a single toy or a whole box of toys, you can treat them the same way: \"Count the price\" or \"Weight it\".\n// You don't care if it's one item or a box of items.\n//\n// Real World Scenario:\n// A Graphic Design App. You can group shapes (Circle, Square) into a \"Group\".\n// You can then move, resize, or color the \"Group\" just like you would a single shape.\n// The \"Group\" COMPOSES multiple shapes but treats them as one unit.\n\ntype Component interface {\n\tSearch(keyword string)\n}\n\n// File is a simple leaf node (Start, End)\ntype File struct {\n\tName string\n}\n\nfunc (f *File) Search(keyword string) {\n\tfmt.Printf(\"Searching for keyword %s in file %s\\n\", keyword, f.Name)\n}\n\n// Folder is a composite that can hold Files or other Folders\ntype Folder struct {\n\tComponents []Component\n\tName       string\n}\n\nfunc (f *Folder) Search(keyword string) {\n\tfmt.Printf(\"Searching recursively for keyword %s in folder %s\\n\", keyword, f.Name)\n\tfor _, composite := range f.Components {\n\t\tcomposite.Search(keyword)\n\t}\n}\n\nfunc (f *Folder) Add(c Component) {\n\tf.Components = append(f.Components, c)\n}\n\nfunc main() {\n\tfmt.Println(\"--- Composite Pattern: Boxes inside Boxes ---\")\n\n\tfile1 := &File{Name: \"File1\"}\n\tfile2 := &File{Name: \"File2\"}\n\tfile3 := &File{Name: \"File3\"}\n\n\tfolder1 := &Folder{Name: \"Folder1\"}\n\tfolder1.Add(file1)\n\n\tfolder2 := &Folder{Name: \"Folder2\"}\n\tfolder2.Add(file2)\n\tfolder2.Add(file3)\n\tfolder2.Add(folder1) // Adding a folder inside a folder!\n\n\tfmt.Println(\"\\nSearching in the top-level folder (Folder2):\")\n\t// One call to search triggers search in ALL sub-folders and files!\n\tfolder2.Search(\"rose\")\n}\n"
          }
        ]
      },
      {
        "name": "decorator",
        "type": "directory",
        "path": "design_patterns/structural/decorator",
        "children": [
          {
            "name": "main.go",
            "type": "file",
            "path": "design_patterns/structural/decorator/main.go",
            "content": "package main\n\nimport \"fmt\"\n\n// Decorator Pattern\n//\n// 5-Year-Old Explanation:\n// Imagine you have a plain vanilla Ice Cream.\n// You can eat it like that.\n// BUT, you can also \"decorate\" it!\n// You can add sprinkles.\n// You can add chocolate sauce.\n// You can add a cherry.\n// It's still an Ice Cream, but now it's YUMMIER!\n//\n// Real World Scenario:\n// Middleware in Web Servers (like adding Logging, Authentication, or Gzip compression).\n// You have a basic \"Handler\" that serves the page.\n// You \"decorate\" it with a Logger. Then you decorate THAT with an Authenticator.\n// The request goes through all the layers (decorators) before reaching the final handler.\n\ntype IceCream interface {\n\tGetCost() int\n\tGetDescription() string\n}\n\n// BasicIceCream is the plain vanilla scoop.\ntype BasicIceCream struct{}\n\nfunc (b *BasicIceCream) GetCost() int {\n\treturn 10 // Cost is $10\n}\n\nfunc (b *BasicIceCream) GetDescription() string {\n\treturn \"Vanilla Ice Cream\"\n}\n\n// -- The Decorators --\n\n// ChocolateSauce adds chocolate to the ice cream.\ntype ChocolateSauce struct {\n\ticeCream IceCream // Contains an Ice Cream inside it\n}\n\nfunc (c *ChocolateSauce) GetCost() int {\n\treturn c.iceCream.GetCost() + 5 // Adds $5\n}\n\nfunc (c *ChocolateSauce) GetDescription() string {\n\treturn c.iceCream.GetDescription() + \" + Chocolate Sauce\"\n}\n\n// Sprinkles adds sprinkles.\ntype Sprinkles struct {\n\ticeCream IceCream\n}\n\nfunc (s *Sprinkles) GetCost() int {\n\treturn s.iceCream.GetCost() + 2 // Adds $2\n}\n\nfunc (s *Sprinkles) GetDescription() string {\n\treturn s.iceCream.GetDescription() + \" + Sprinkles\"\n}\n\nfunc main() {\n\tfmt.Println(\"--- Decorator Pattern: Making Ice Cream Yummy ---\")\n\n\t// 1. Plain Ice Cream\n\tvar myIceCream IceCream = &BasicIceCream{}\n\tfmt.Printf(\"Order 1: %s. Cost: $%d\\n\", myIceCream.GetDescription(), myIceCream.GetCost())\n\n\t// 2. Add Chocolate Sauce\n\tmyIceCream = &ChocolateSauce{iceCream: myIceCream}\n\tfmt.Printf(\"Order 2: %s. Cost: $%d\\n\", myIceCream.GetDescription(), myIceCream.GetCost())\n\n\t// 3. Add Sprinkles\n\tmyIceCream = &Sprinkles{iceCream: myIceCream}\n\tfmt.Printf(\"Order 3: %s. Cost: $%d\\n\", myIceCream.GetDescription(), myIceCream.GetCost())\n}\n"
          }
        ]
      },
      {
        "name": "facade",
        "type": "directory",
        "path": "design_patterns/structural/facade",
        "children": [
          {
            "name": "main.go",
            "type": "file",
            "path": "design_patterns/structural/facade/main.go",
            "content": "package main\n\nimport \"fmt\"\n\n// Facade Pattern\n//\n// 5-Year-Old Explanation:\n// Imagine you want to play a video game.\n// You have to:\n// 1. Turn on the TV.\n// 2. Turn on the Sound System.\n// 3. Turn on the Game Console.\n// 4. Select the right input on TV.\n// That's too many buttons!\n// A \"Facade\" is like a magical single button that says \"PLAY GAME\".\n// You press it, and it does ALL those things for you automatically.\n//\n// Real World Scenario:\n// A \"One-Click Checkout\" button.\n// Behind the scenes, it:\n// 1. Checks inventory.\n// 2. Verifies payment.\n// 3. Calculates shipping.\n// 4. Sends confirmation email.\n// The user sees ONE simple action, but the Facade handles the complex mess behind it.\n\n// -- Complex Subsystem Parts --\n\ntype TV struct{}\n\nfunc (t *TV) On()  { fmt.Println(\"TV: Turning ON\") }\nfunc (t *TV) Off() { fmt.Println(\"TV: Turning OFF\") }\n\ntype SoundSystem struct{}\n\nfunc (s *SoundSystem) On()               { fmt.Println(\"Sound: Turning ON\") }\nfunc (s *SoundSystem) SetVolume(vol int) { fmt.Printf(\"Sound: Volume set to %d\\n\", vol) }\nfunc (s *SoundSystem) Off()              { fmt.Println(\"Sound: Turning OFF\") }\n\ntype GameConsole struct{}\n\nfunc (g *GameConsole) On()        { fmt.Println(\"Console: Turning ON\") }\nfunc (g *GameConsole) StartGame() { fmt.Println(\"Console: Starting the game...\") }\nfunc (g *GameConsole) Off()       { fmt.Println(\"Console: Turning OFF\") }\n\n// -- The Facade --\n\ntype GameFacade struct {\n\ttv      *TV\n\tsound   *SoundSystem\n\tconsole *GameConsole\n}\n\nfunc NewGameFacade() *GameFacade {\n\treturn &GameFacade{\n\t\ttv:      &TV{},\n\t\tsound:   &SoundSystem{},\n\t\tconsole: &GameConsole{},\n\t}\n}\n\n// PlayGame is the simple button\nfunc (g *GameFacade) PlayGame() {\n\tfmt.Println(\"\\n>>> Master Button: PLAY GAME <<<\")\n\tg.tv.On()\n\tg.sound.On()\n\tg.sound.SetVolume(50)\n\tg.console.On()\n\tg.console.StartGame()\n\tfmt.Println(\">>> Ready to play! <<<\")\n}\n\n// StopGame is another simple button\nfunc (g *GameFacade) StopGame() {\n\tfmt.Println(\"\\n>>> Master Button: STOP GAME <<<\")\n\tg.console.Off()\n\tg.sound.Off()\n\tg.tv.Off()\n\tfmt.Println(\">>> Goodnight! <<<\")\n}\n\nfunc main() {\n\tfmt.Println(\"--- Facade Pattern: The Master Button ---\")\n\n\tfacade := NewGameFacade()\n\n\t// Start everything with one call\n\tfacade.PlayGame()\n\n\t// Stop everything with one call\n\tfacade.StopGame()\n}\n"
          }
        ]
      },
      {
        "name": "proxy",
        "type": "directory",
        "path": "design_patterns/structural/proxy",
        "children": [
          {
            "name": "main.go",
            "type": "file",
            "path": "design_patterns/structural/proxy/main.go",
            "content": "package main\n\nimport \"fmt\"\n\n// Proxy Pattern\n//\n// 5-Year-Old Explanation:\n// Imagine a secret clubhouse.\n// You can't just walk in.\n// There is a Security Guard (The Proxy) at the door.\n// The Guard asks: \"What is the password?\"\n// If you know the password, the Guard lets you in (Accesses the Real Object).\n// If you don't know it, the Guard says \"STOP! Go away!\"\n//\n// Real World Scenario:\n// A Cache Proxy or Access Control.\n// - Cache: Before asking the real database (which is slow), check if we already have the answer in memory (fast).\n// - Access Control: Before letting a user delete a file, check if they are an Admin.\n\ntype Door interface {\n\tOpen(password string)\n}\n\n// RealDoor is the actual door to the clubhouse.\ntype RealDoor struct{}\n\nfunc (r *RealDoor) Open(password string) {\n\tfmt.Println(\"Door: Squeak... The door opens. Welcome to the Secret Clubhouse!\")\n}\n\n// SecurityProxy is the guard protecting the door.\ntype SecurityProxy struct {\n\tdoor *RealDoor\n}\n\nfunc (s *SecurityProxy) Open(password string) {\n\tif password == \"secret123\" {\n\t\tfmt.Println(\"Proxy: Password correct! Opening the door.\")\n\t\tif s.door == nil {\n\t\t\ts.door = &RealDoor{}\n\t\t}\n\t\ts.door.Open(password)\n\t} else {\n\t\tfmt.Println(\"Proxy: WRONG PASSWORD! You cannot enter!\")\n\t}\n}\n\nfunc main() {\n\tfmt.Println(\"--- Proxy Pattern: The Security Guard ---\")\n\n\tvar myDoor Door = &SecurityProxy{}\n\n\t// 1. Try with wrong password\n\tfmt.Println(\"\\nKid: Can I come in? (Password: pizza)\")\n\tmyDoor.Open(\"pizza\")\n\n\t// 2. Try with correct password\n\tfmt.Println(\"\\nKid: Can I come in? (Password: secret123)\")\n\tmyDoor.Open(\"secret123\")\n}\n"
          }
        ]
      }
    ]
  }
]